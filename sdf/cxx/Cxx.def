
definition
module Cxx

imports

  TranslationUnits

exports

  context-free start-symbols
    TranslationUnit
module OperatorFunctionIds

imports

  TemplateIds

exports
  sorts
    Operator

exports

  sorts
    OperatorFunctionId

  context-free syntax

    %% A.11 [gram.over]
    "operator" Operator                                   -> OperatorFunctionId

    "operator" Operator "<" tal:TemplateArgumentList? ">" -> OperatorFunctionId

    %% A.11 [gram.over]
    "new"      -> Operator
    "delete"   -> Operator
    "new[]"    -> Operator
    "delete[]" -> Operator
    "+"        -> Operator
    "-"        -> Operator
    "*"        -> Operator
    "/"        -> Operator
    "%"        -> Operator
    "^"        -> Operator
    "&"        -> Operator
    "|"        -> Operator
    "~"        -> Operator
    "!"        -> Operator
    "="        -> Operator
    "<"        -> Operator
    ">"        -> Operator
    "+="       -> Operator
    "-="       -> Operator
    "*="       -> Operator
    "/="       -> Operator
    "%="       -> Operator
    "^="       -> Operator
    "&="       -> Operator
    "|="       -> Operator
    "<<"       -> Operator
    ">>"       -> Operator
    ">>="      -> Operator
    "<<="      -> Operator
    "=="       -> Operator
    "!="       -> Operator
    "<="       -> Operator
    ">="       -> Operator
    "&&"       -> Operator
    "||"       -> Operator
    "++"       -> Operator
    "--"       -> Operator
    ","        -> Operator
    "->*"      -> Operator
    "->"       -> Operator
    "()"       -> Operator
    "[]"       -> Operator

    "and"      -> Operator
    "bitor"    -> Operator
    "or"       -> Operator
    "xor"      -> Operator
    "compl"    -> Operator
    "bitand"   -> Operator
    "and_eq"   -> Operator
    "or_eq"    -> Operator
    "xor_eq"   -> Operator
    "not"      -> Operator  {cons("not-op")}
    "not_eq"   -> Operator

module CastExpressions

imports

  CastExpressions
  UnaryExpressions
  TypeIds

exports

  sorts
    CastExpression

  context-free syntax

    %% 5.4 [expr.cast]
    UnaryExpression               -> CastExpression
    "(" TypeId ")" CastExpression -> CastExpression

module FunctionSpecifiers

exports

  sorts
    FunctionSpecifier

  context-free syntax

    %% 7.1.2 [dcl.fct.spec]
    "inline"   -> FunctionSpecifier
    "virtual"  -> FunctionSpecifier
    "explicit" -> FunctionSpecifier

module Declarators

imports

  ConstantExpressions
  CvQualifiers
  ExceptionSpecifications
  IdExpressions
  ParameterDeclarations
  SimpleTypeSpecifiers

exports

  sorts
    DirectDeclarator
    DeclaratorId

exports

  sorts
    Declarator
    PtrOperator

  context-free syntax

    %% 8 [dcl.decl]
    DirectDeclarator       -> Declarator

    PtrOperator Declarator -> Declarator

    %% 8 [dcl.decl]
    DeclaratorId                                             -> DirectDeclarator


    DirectDeclarator "(" ParameterDeclarationClause ")"
    cqs:CvQualifierSeq? es:ExceptionSpecification?           -> DirectDeclarator

    DirectDeclarator "[" ce:ConstantExpression? "]"
                                                             -> DirectDeclarator

    "(" Declarator ")"
                                                             -> DirectDeclarator


    %% 8 [dcl.decl]
    "*" cqs:CvQualifierSeq?                                -> PtrOperator

    CvQualifierSeq -> CvQualifierSeq?

    -> CvQualifierSeq?

    "&"                                                    -> PtrOperator


    r:Root NestedNameSpecifier "*" cvs:CvQualifierSeq? -> PtrOperator

    %% 8 [dcl.decl]
    IdExpression                                 -> DeclaratorId

    Root nns:NestedNameSpecifier? TypeName     -> DeclaratorId

    %%FIXME: In sdf-attribute, root.ok should be a local even if all rules
    %%       define it. But for the moment we declare an dummy rule without
    %%       root.ok.
    "buggy" -> DeclaratorId {avoid}
module TemplateParameters

imports

  ParameterDeclarations
  TemplateDeclarations
  TypeIds

exports

  sorts
    TypeParameter
    TemplateParameter

  context-free syntax

    %% 14.1 [temp.param]
    TypeParameter        -> TemplateParameter
    ParameterDeclaration -> TemplateParameter

    %% 14.1 [temp.param]
    "class" i:Identifier?                                  -> TypeParameter

    "class" i:Identifier? "=" TypeId                       -> TypeParameter

    "typename" i:Identifier?                               -> TypeParameter


    "typename" i:Identifier? "=" TypeId                    -> TypeParameter

    "template" "<" TemplateParameterList ">" "class" i:Identifier?
                                                            -> TypeParameter

    "template" "<" TemplateParameterList ">" "class" i:Identifier? "="
    IdExpression                                            -> TypeParameter

module DeclarationStatements

imports
  Declarations

exports

  sorts
    DeclarationStatement

  context-free syntax

    %% 6.7 [stmt.dcl]
    BlockDeclaration -> DeclarationStatement

module PmExpressions

imports

  CastExpressions

exports

  sorts
    PmExpression

  context-free syntax

    %% 5.5 [expr.mptr.oper]
    CastExpression                    -> PmExpression
    PmExpression ".*" CastExpression  -> PmExpression

    PmExpression "->*" CastExpression -> PmExpression

module ThrowExpressions

imports

  AssignmentExpressions

exports

  sorts
    ThrowExpression

  context-free syntax

    %% 15 [except]
    "throw" AssignmentExpression? -> ThrowExpression

module InclusiveOrExpressions

imports

  ExclusiveOrExpressions

exports

  sorts
    InclusiveOrExpression

  context-free syntax

    %% 5.13 [expr.or]
    ExclusiveOrExpression                           -> InclusiveOrExpression
    InclusiveOrExpression "|" ExclusiveOrExpression -> InclusiveOrExpression

    InclusiveOrExpression "bitor" ExclusiveOrExpression
                                                    -> InclusiveOrExpression

module CompoundStatements

imports

  Statements

exports

  sorts
    StatementSeq

exports

  sorts
    CompoundStatement

  context-free syntax

    %% 6.3 [stmt.block]
    "{" ss:StatementSeq? "}" -> CompoundStatement

    %% 6.3 [stmt.block]
    Statement+ -> StatementSeq

module NewExpressions

imports

  Expressions
  PostfixExpressions
  TypeIds

exports

  sorts
    NewPlacement
    NewTypeId
    NewDeclarator
    DirectNewDeclarator
    NewInitializer

exports

  sorts
    NewExpression

  context-free syntax

    %% 5.3.4 [expr.new]
    root:"::"? "new" np:NewPlacement? NewTypeId ni:NewInitializer?
                                                         -> NewExpression

    root:"::"? "new" np:NewPlacement? "(" TypeId ")" ni:NewInitializer?
                                                         -> NewExpression

    %% 5.3.4 [expr.new]
    "(" ExpressionList ")" -> NewPlacement

    %% 5.3.4 [expr.new]
    TypeSpecifierSeq nd:NewDeclarator? -> NewTypeId

    %% 5.3.4 [expr.new]
    PtrOperator nd:NewDeclarator? -> NewDeclarator

    DirectNewDeclarator           -> NewDeclarator

    %% 5.3.4 [expr.new]
    "[" Expression "]"                             -> DirectNewDeclarator

    DirectNewDeclarator "[" ConstantExpression "]" -> DirectNewDeclarator

    %% 5.3.4 [expr.new]
    "(" el:ExpressionList? ")" -> NewInitializer

module IterationStatements

imports

  Statements
  SelectionStatements
  ExpressionStatements
  Declarations

exports

  sorts
    ForInitStatement

exports

  sorts
    IterationStatement

  context-free syntax

    %% 6.5 [stmt.iter]
    "while" "(" Condition ")" Statement                 -> IterationStatement

    "do" Statement "while" "(" Expression ")" ";"       -> IterationStatement

    "for" "(" ForInitStatement cond:Condition? ";" expr:Expression? ")"
    Statement                                           -> IterationStatement

    %% 6.5 [stmt.iter]
    ExpressionStatement -> ForInitStatement
    SimpleDeclaration   -> ForInitStatement


module Namespaces

imports

  Declarations
  Identifiers
  NamespaceAliases

exports

  sorts
    ExtensionNamespaceDefinition
    UnnamedNamespaceDefinition

exports

  sorts
    OriginalNamespaceDefinition
    OriginalNamespaceName
    NamespaceBody
    NamespaceName
    NamespaceDefinition
    NamedNamespaceDefinition

  context-free syntax

    %% 7.3.1 [namespace.def]
    OriginalNamespaceName -> NamespaceName
    NamespaceAlias        -> NamespaceName

    %% 7.3.1 [namespace.def]
    Identifier -> OriginalNamespaceName

    %% 7.3.1 [namespace.def]
    NamedNamespaceDefinition   -> NamespaceDefinition
    UnnamedNamespaceDefinition -> NamespaceDefinition

    %% 7.3.1 [namespace.def]
    OriginalNamespaceDefinition  -> NamedNamespaceDefinition
    ExtensionNamespaceDefinition -> NamedNamespaceDefinition

    %% 7.3.1 [namespace.def]
    "namespace" Identifier "{" NamespaceBody "}" -> OriginalNamespaceDefinition

    %% 7.3.1 [namespace.def]
    "namespace" org:OriginalNamespaceName "{" NamespaceBody "}"
                                      -> ExtensionNamespaceDefinition

    %% 7.3.1 [namespace.def]
    "namespace" "{" NamespaceBody "}" -> UnnamedNamespaceDefinition

    %% 7.3.1 [namespace.def]
    DeclarationSeq? -> NamespaceBody


module SelectionStatements

imports

  AssignmentExpressions
  Expressions
  Statements

exports

  sorts
    Condition
    SelectionStatement

  context-free syntax

    %% 6.4 [stmt.select]
    "if" "(" Condition ")" Statement                  -> SelectionStatement

    "if" "(" Condition ")" st1:Statement "else" st2:Statement
                                                      -> SelectionStatement

    "switch" "(" Condition ")" Statement              -> SelectionStatement

    %% 6.4 [stmt.select]
    %% FIXME: Condition?
    Expression                                           -> Condition
    %% FIXME: Condition?
    TypeSpecifierSeq Declarator "=" AssignmentExpression -> Condition

module Initializers

imports

  AssignmentExpressions
  PostfixExpressions

exports

  sorts
    InitializerClause
    InitializerList

exports

  sorts
    Initializer

  context-free syntax

    %% If there is an initializer, we assume that the declarator refer to a
    %% new object-name
    Initializer -> Initializer?
                -> Initializer?

    %% 8.5 [dcl.init]
    "=" InitializerClause  -> Initializer
    "(" ExpressionList ")" -> Initializer

    %% 8.5 [dcl.init]
    AssignmentExpression               -> InitializerClause
    "{" InitializerList comma:","? "}" -> InitializerClause

    "{" "}"                            -> InitializerClause

    %% 8.5 [dcl.init]
    list:{ InitializerClause "," }+    -> InitializerList

module MemberSpecifications

imports

  AccessSpecifiers
  ConstantExpressions
  FunctionDefinitions
  IdExpressions
  Identifiers
  Specifiers
  UsingDeclarations
  TemplateDeclarations

exports

  sorts
    MemberDeclarator
    MemberDeclaratorList
    ConstantInitializer
    PureSpecifier

exports

  sorts
    MemberSpecification
    MemberDeclaration

  context-free syntax

    %% 9.2 [class.mem]
    MemberDeclaration ms:MemberSpecification?   -> MemberSpecification
    AccessSpecifier ":" ms:MemberSpecification? -> MemberSpecification

    %% 9.2 [class.mem]
    ds:DeclSpecifierSeq? mdl:MemberDeclaratorList? ";"   -> MemberDeclaration

    FunctionDefinition semi:";"?                          -> MemberDeclaration

    root:"::"? nns:NestedNameSpecifier template:"template"? UnqualifiedId ";"
                                                          -> MemberDeclaration
    UsingDeclaration                                      -> MemberDeclaration
    TemplateDeclaration                                   -> MemberDeclaration


    MemberDeclaratorList -> MemberDeclaratorList?
                         -> MemberDeclaratorList?

    %% 9.2 [class.mem]
    list:{ MemberDeclarator ","}+ -> MemberDeclaratorList

    l1:{ MemberDeclarator "," }+ "," l2:{ MemberDeclarator "," }+ -> { MemberDeclarator "," }+

    MemberDeclarator -> { MemberDeclarator "," }+

    %%FIXME
    l:{MemberDeclarator ","}+ "," {MemberDeclarator ","}* -> {MemberDeclarator ","}+
      {avoid}
    {MemberDeclarator ","}* "," l:{MemberDeclarator ","}+ -> {MemberDeclarator ","}+
      {avoid}
    l:{MemberDeclarator ","}+ -> {MemberDeclarator ","}*
      {avoid}


    %% 9.2 [class.mem]
    %% Declarator PureSpecifier?          -> MemberDeclarator
    %% Declarator ConstantInitializer?    -> MemberDeclarator
    %% Identifier? ":" ConstantExpression -> MemberDeclarator

    %% The chunk of grammar above generates useless ambiguities
    %% when both `PureSpecifier?' and `ConstantInitializer?' are
    %% empty.  It will work better this way:
    Declarator                         -> MemberDeclarator

    Declarator PureSpecifier           -> MemberDeclarator

    Declarator ConstantInitializer     -> MemberDeclarator

    i:Identifier? ":" ConstantExpression -> MemberDeclarator

    %% 9.2 [class.mem]
    "=" "0" -> PureSpecifier

    %% 9.2 [class.mem]
    "=" ConstantExpression -> ConstantInitializer

module EscapeSequences

imports

  Characters

exports

  sorts
    SIMPLE-ESCAPE-SEQUENCE
    OCTAL-ESCAPE-SEQUENCE
    OCTAL-ESCAPE-SEQUENCE1
    OCTAL-ESCAPE-SEQUENCE2
    OCTAL-ESCAPE-SEQUENCE3
    OCTAL-ESCAPE-SEQUENCE4
    HEXADECIMAL-ESCAPE-SEQUENCE
    HEX-QUAD

exports

  sorts
    ESCAPE-SEQUENCE
    UNIVERSAL-CHARACTER-NAME

  lexical syntax

    %% 2.13.2 [lex.ccon]
    SIMPLE-ESCAPE-SEQUENCE      -> ESCAPE-SEQUENCE
    OCTAL-ESCAPE-SEQUENCE       -> ESCAPE-SEQUENCE
    HEXADECIMAL-ESCAPE-SEQUENCE -> ESCAPE-SEQUENCE

    %% 2.13.2 [lex.ccon]
    "\\'"  -> SIMPLE-ESCAPE-SEQUENCE
    "\\\"" -> SIMPLE-ESCAPE-SEQUENCE
    "\\?"  -> SIMPLE-ESCAPE-SEQUENCE
    "\\\\" -> SIMPLE-ESCAPE-SEQUENCE
    "\\a"  -> SIMPLE-ESCAPE-SEQUENCE
    "\\b"  -> SIMPLE-ESCAPE-SEQUENCE
    "\\f"  -> SIMPLE-ESCAPE-SEQUENCE
    "\\n"  -> SIMPLE-ESCAPE-SEQUENCE
    "\\r"  -> SIMPLE-ESCAPE-SEQUENCE
    "\\t"  -> SIMPLE-ESCAPE-SEQUENCE
    "\\v"  -> SIMPLE-ESCAPE-SEQUENCE

    %% 2.13.2 [lex.ccon]
    "\\" OCTAL-DIGIT                         	 -> OCTAL-ESCAPE-SEQUENCE1
    "\\" LOW-OCTAL-DIGIT OCTAL-DIGIT             -> OCTAL-ESCAPE-SEQUENCE2
    "\\" HIGH-OCTAL-DIGIT OCTAL-DIGIT            -> OCTAL-ESCAPE-SEQUENCE3
    "\\" LOW-OCTAL-DIGIT OCTAL-DIGIT OCTAL-DIGIT -> OCTAL-ESCAPE-SEQUENCE4

    OCTAL-ESCAPE-SEQUENCE1 -> OCTAL-ESCAPE-SEQUENCE
    OCTAL-ESCAPE-SEQUENCE2 -> OCTAL-ESCAPE-SEQUENCE
    OCTAL-ESCAPE-SEQUENCE3 -> OCTAL-ESCAPE-SEQUENCE
    OCTAL-ESCAPE-SEQUENCE4 -> OCTAL-ESCAPE-SEQUENCE

  lexical restrictions

    OCTAL-ESCAPE-SEQUENCE1 -/- [0-7]
    OCTAL-ESCAPE-SEQUENCE2 -/- [0-7]

  lexical syntax

    %% 2.13.2 [lex.ccon]
    "\\x" HEXADECIMAL-DIGIT+ -> HEXADECIMAL-ESCAPE-SEQUENCE

  lexical restrictions

    HEXADECIMAL-ESCAPE-SEQUENCE	 -/- [0-9a-fA-F]

  lexical syntax

    %% 2.13.2 [lex.ccon]
    HEXADECIMAL-DIGIT HEXADECIMAL-DIGIT HEXADECIMAL-DIGIT HEXADECIMAL-DIGIT
                                                 -> HEX-QUAD
    "\\u" HEX-QUAD                               -> UNIVERSAL-CHARACTER-NAME
    "\\U" HEX-QUAD HEX-QUAD                      -> UNIVERSAL-CHARACTER-NAME

module TemplateDeclarations

imports

  Declarations
  TemplateParameters

exports

  sorts
    TemplateDeclaration
    TemplateParameterList

  context-free syntax

    %% 14 [temp]
    exp:"export"? "template" "<" TemplateParameterList ">" Declaration
                                                     -> TemplateDeclaration

    "buggy" -> TemplateDeclaration {avoid}

    %% 14 [temp]
    list:{ TemplateParameter "," }+ -> TemplateParameterList

module LogicalOrExpressions

imports

  LogicalAndExpressions

exports

  sorts
    LogicalOrExpression

  context-free syntax

    %% 5.15 [expr.log.or]
    LogicalAndExpression                          -> LogicalOrExpression
    LogicalOrExpression "||" LogicalAndExpression -> LogicalOrExpression

    LogicalOrExpression "or" LogicalAndExpression -> LogicalOrExpression

module IntegerLiterals

imports

  Characters

exports

  sorts
    INTEGER-LITERAL
    DECIMAL-LITERAL
    OCTAL-LITERAL
    HEXADECIMAL-LITERAL
    INTEGER-SUFFIX
    UNSIGNED-SUFFIX
    LONG-SUFFIX

exports

  sorts
    IntegerLiteral

  lexical syntax

    %% 2.13.1 [lex.icon]
    DECIMAL-LITERAL INTEGER-SUFFIX?     -> INTEGER-LITERAL
    OCTAL-LITERAL INTEGER-SUFFIX?       -> INTEGER-LITERAL
    HEXADECIMAL-LITERAL INTEGER-SUFFIX? -> INTEGER-LITERAL

    %% 2.13.1 [lex.icon]
    NONZERO-DIGIT DIGIT* -> DECIMAL-LITERAL

    %% 2.13.1 [lex.icon]
    "0" OCTAL-DIGIT* -> OCTAL-LITERAL

    %% 2.13.1 [lex.icon]
    "0x" HEXADECIMAL-DIGIT* -> HEXADECIMAL-LITERAL
    "0X" HEXADECIMAL-DIGIT* -> HEXADECIMAL-LITERAL

    %% 2.13.1 [lex.icon]
    UNSIGNED-SUFFIX LONG-SUFFIX? -> INTEGER-SUFFIX
    LONG-SUFFIX UNSIGNED-SUFFIX? -> INTEGER-SUFFIX

    %% 2.13.1 [lex.icon]
    [uU] -> UNSIGNED-SUFFIX
    [lL] -> LONG-SUFFIX

  context-free syntax

    INTEGER-LITERAL -> IntegerLiteral

  lexical restrictions

    INTEGER-LITERAL -/- [\.]
module TemplateIds

imports

  AssignmentExpressions
  IdExpressions
  TypeIds

exports

  sorts
    TemplateName
    TemplateArgument

exports

  sorts
    TemplateId
    TemplateArgumentList

  context-free syntax

    %% 14.2 [temp.names]
    TemplateName "<" tal:TemplateArgumentList? ">" -> TemplateId

    TemplateArgumentList -> TemplateArgumentList?

                         -> TemplateArgumentList?

    %% 14.2 [temp.names]
    Identifier -> TemplateName

    %% 14.2 [temp.names]
    list:{ TemplateArgument "," }+ -> TemplateArgumentList

    l:{ TemplateArgument "," }+ "," r:{ TemplateArgument "," }+
         -> { TemplateArgument "," }+
        {left}

    %%FIXME
    {TemplateArgument ","}+ "," {TemplateArgument ","}*
      -> {TemplateArgument ","}+
      {avoid}
    {TemplateArgument ","}* "," {TemplateArgument ","}+
      -> {TemplateArgument ","}+
      {avoid}

    TemplateArgument -> { TemplateArgument "," }+

    %% 14.2 [temp.names]
    AssignmentExpression -> TemplateArgument

    TypeId               -> TemplateArgument

    %% FIXME: This rule produces ambiguous parse trees, since IdExpression
    %% also reduces as AssignmentExpression.
    %% IdExpression      -> TemplateArgument

module AssignmentExpressions

imports

  ConditionalExpressions
  LogicalOrExpressions
  ThrowExpressions

exports

  sorts
    AssignmentOperator

exports

  sorts
    AssignmentExpression

  context-free syntax

    %% 5.17 [expr.ass]
    ConditionalExpression
                                            -> AssignmentExpression
    LogicalOrExpression AssignmentOperator AssignmentExpression
                                            -> AssignmentExpression
    ThrowExpression
                                           -> AssignmentExpression

    %% 5.17 [expr.ass]
    "="   -> AssignmentOperator
    "*="  -> AssignmentOperator
    "/="  -> AssignmentOperator
    "%="  -> AssignmentOperator
    "+="  -> AssignmentOperator
    "-="  -> AssignmentOperator
    ">>=" -> AssignmentOperator
    "<<=" -> AssignmentOperator
    "&="  -> AssignmentOperator
    "^="  -> AssignmentOperator
    "|="  -> AssignmentOperator

    "and_eq" -> AssignmentOperator
    "or_eq"  -> AssignmentOperator
    "xor_eq" -> AssignmentOperator

module UsingDirectives

imports

  IdExpressions
  Namespaces

exports

  sorts
    UsingDirective

  context-free syntax

    %% 7.3.4 [namespace.udir]
    "using" "namespace" Root nns:NestedNameSpecifier? NamespaceName ";"
                                                            -> UsingDirective

module DeleteExpressions

imports

  CastExpressions

exports

  sorts
    DeleteExpression

  context-free syntax

    %% 5.3.5 [expr.delete]
    root:"::"? "delete" CastExpression         -> DeleteExpression
    root:"::"? "delete" "[" "]" CastExpression -> DeleteExpression


module ConstantExpressions

imports

  ConditionalExpressions

exports

  sorts
    ConstantExpression

  context-free syntax

    %% 5.19 [expr.const]
    ConditionalExpression -> ConstantExpression

module InitDeclarators

imports

  Declarators
  Initializers

exports

  sorts
    InitDeclarator

exports

  sorts
    InitDeclaratorList


  context-free syntax

    %% 8 [dcl.decl]
    InitDeclaratorList           -> InitDeclaratorList?

                                 -> InitDeclaratorList?

    list:{ InitDeclarator "," }+ -> InitDeclaratorList

    l1:{ InitDeclarator "," }+ "," l2:{ InitDeclarator "," }+ -> { InitDeclarator "," }+

    InitDeclarator -> { InitDeclarator "," }+

    %%FIXME
    l:{InitDeclarator ","}+ "," {InitDeclarator ","}* -> {InitDeclarator ","}+
      {avoid}
    {InitDeclarator ","}* "," l:{InitDeclarator ","}+ -> {InitDeclarator ","}+
      {avoid}
    l:{InitDeclarator ","}+ -> {InitDeclarator ","}*
      {avoid}

    %% 8 [dcl.decl]
    Declarator init:Initializer? -> InitDeclarator

module Specifiers

imports

  FunctionSpecifiers
  StorageClassSpecifiers
  TypeSpecifiers

exports

  sorts
    DeclSpecifier
    DeclSpecifierSeq

  context-free syntax

    %% 7.1 [dcl.spec]
    StorageClassSpecifier -> DeclSpecifier 
    TypeSpecifier         -> DeclSpecifier 
    FunctionSpecifier     -> DeclSpecifier 

    "friend"              -> DeclSpecifier 
    "typedef"             -> DeclSpecifier 

    %% 7.1 [dcl.spec]
    DeclSpecifierSeq     -> DeclSpecifierSeq?
                        -> DeclSpecifierSeq?

    list:DeclSpecifier+ -> DeclSpecifierSeq

    l:DeclSpecifier+ r:DeclSpecifier+ -> DeclSpecifier+
      {left}

    DeclSpecifier -> DeclSpecifier+


   %%FIXME
 DeclSpecifier+ DeclSpecifier* -> DeclSpecifier+
      {avoid}
 DeclSpecifier* DeclSpecifier+ -> DeclSpecifier+
      {avoid}
module ElaboratedTypeSpecifiers

imports

  ClassSpecifiers
  IdExpressions
  Identifiers
  TemplateIds

exports

  sorts
     ElaboratedTypeSpecifier

  context-free syntax

    %% 7.1.5.3 [dcl.type.elab]

    ClassKey r:Root nns:NestedNameSpecifier? Identifier
                                           -> ElaboratedTypeSpecifier

    ClassKey r:Root nns:NestedNameSpecifier?
    template:"template"? TemplateId        -> ElaboratedTypeSpecifier

    "enum" r:Root nns:NestedNameSpecifier? Identifier
                                           -> ElaboratedTypeSpecifier

    "typename" r:Root NestedNameSpecifier Identifier
                                           -> ElaboratedTypeSpecifier

    "typename" r:Root NestedNameSpecifier
    template:"template"? TemplateId        -> ElaboratedTypeSpecifier

module EqualityExpressions

imports

  RelationalExpressions

exports

  sorts
    EqualityExpression

  context-free syntax

    %% 5.10 [expr.eq]
    RelationalExpression                             -> EqualityExpression
    EqualityExpression "==" RelationalExpression     -> EqualityExpression

    EqualityExpression "!=" RelationalExpression     -> EqualityExpression

    EqualityExpression "not_eq" RelationalExpression -> EqualityExpression

module LinkageSpecifications

imports

  Declarations
  StringLiterals

exports

  sorts
    LinkageSpecification

  context-free syntax

    %% 7.5 [dcl.link]
    "extern" StringLiteral "{" ds:DeclarationSeq? "}" -> LinkageSpecification
    "extern" StringLiteral Declaration             -> LinkageSpecification

module CtorInitializers

imports

  ClassSpecifiers
  IdExpressions
  PostfixExpressions

exports

  sorts
    MemInitializerList
    MemInitializerId

exports

  sorts
    CtorInitializer
    MemInitializer

  context-free syntax

    %% A.10 [gram.special]
    ":" MemInitializerList                      -> CtorInitializer

    %% A.10 [gram.special]
    list:{ MemInitializer "," }+                -> MemInitializerList

    %% A.10 [gram.special]
    MemInitializerId "(" el:ExpressionList? ")" -> MemInitializer

    %% A.10 [gram.special]
    root:"::"? nns:NestedNameSpecifier? ClassName -> MemInitializerId
    Identifier                                  -> MemInitializerId

module EnumSpecifiers

imports

  Identifiers
  ConstantExpressions

exports

  sorts
    EnumeratorList
    EnumeratorDefinition

exports

  sorts
    EnumName
    EnumSpecifier
    Enumerator

  context-free syntax

    %% 7.2 [dcl.enum]
    Identifier -> EnumName

    %% 7.2 [dcl.enum]
    "enum" i:Identifier? "{" el:EnumeratorList? "}" -> EnumSpecifier

    %% 7.2 [dcl.enum]
    list:{ EnumeratorDefinition "," }+ -> EnumeratorList

    %% 7.2 [dcl.enum]
    Enumerator                         -> EnumeratorDefinition
    Enumerator "=" ConstantExpression  -> EnumeratorDefinition

    %% 7.2 [dcl.enum]
    %% There are no ambiguities on enumerators.
    Identifier -> Enumerator

module ExclusiveOrExpressions

imports

  AndExpressions

exports

  sorts
     ExclusiveOrExpression

  context-free syntax

    %% 5.12 [expr.xor]
    AndExpression                             -> ExclusiveOrExpression
    ExclusiveOrExpression "^" AndExpression   -> ExclusiveOrExpression
    ExclusiveOrExpression "xor" AndExpression -> ExclusiveOrExpression

module StringLiterals

imports

  Characters
  EscapeSequences

exports

  sorts
    STRING-LITERAL
    S-CHAR
    S-CHAR-SEQUENCE

exports

  sorts
    StringLiteral

  lexical syntax

    %% 2.13.4 [lex.string]
    "\"" S-CHAR-SEQUENCE? "\""  -> STRING-LITERAL
    "L\"" S-CHAR-SEQUENCE? "\"" -> STRING-LITERAL

    %% 2.13.4 [lex.string]
    S-CHAR+ -> S-CHAR-SEQUENCE

    %% 2.13.4 [lex.string]
    S-SOURCE-CHARACTER       -> S-CHAR
    ESCAPE-SEQUENCE          -> S-CHAR
    UNIVERSAL-CHARACTER-NAME -> S-CHAR

  context-free syntax

    STRING-LITERAL -> StringLiteral

module Keywords

imports

  Layout
  Identifiers

exports

  context-free syntax

    %% 2.11 [lex.key]
    "asm"              -> Identifier { reject }
    "auto"             -> Identifier { reject }
    "bool"             -> Identifier { reject }
    "break"            -> Identifier { reject }
    "case"             -> Identifier { reject }
    "catch"            -> Identifier { reject }
    "char"             -> Identifier { reject }
    "class"            -> Identifier { reject }
    "const"            -> Identifier { reject }
    "const_cast"       -> Identifier { reject }
    "continue"         -> Identifier { reject }
    "default"          -> Identifier { reject }
    "delete"           -> Identifier { reject }
    "do"               -> Identifier { reject }
    "double"           -> Identifier { reject }
    "dynamic_cast"     -> Identifier { reject }
    "else"             -> Identifier { reject }
    "enum"             -> Identifier { reject }
    "explicit"         -> Identifier { reject }
    "export"           -> Identifier { reject }
    "extern"           -> Identifier { reject }
    "false"            -> Identifier { reject }
    "float"            -> Identifier { reject }
    "for"              -> Identifier { reject }
    "friend"           -> Identifier { reject }
    "goto"             -> Identifier { reject }
    "if"               -> Identifier { reject }
    "inline"           -> Identifier { reject }
    "int"              -> Identifier { reject }
    "long"             -> Identifier { reject }
    "mutable"          -> Identifier { reject }
    "namespace"        -> Identifier { reject }
    "new"              -> Identifier { reject }
    "operator"         -> Identifier { reject }
    "private"          -> Identifier { reject }
    "protected"        -> Identifier { reject }
    "public"           -> Identifier { reject }
    "register"         -> Identifier { reject }
    "reinterpret_cast" -> Identifier { reject }
    "return"           -> Identifier { reject }
    "short"            -> Identifier { reject }
    "signed"           -> Identifier { reject }
    "sizeof"           -> Identifier { reject }
    "static"           -> Identifier { reject }
    "static_cast"      -> Identifier { reject }
    "struct"           -> Identifier { reject }
    "switch"           -> Identifier { reject }
    "template"         -> Identifier { reject }
    "this"             -> Identifier { reject }
    "throw"            -> Identifier { reject }
    "true"             -> Identifier { reject }
    "try"              -> Identifier { reject }
    "typedef"          -> Identifier { reject }
    "typeid"           -> Identifier { reject }
    "typename"         -> Identifier { reject }
    "union"            -> Identifier { reject }
    "unsigned"         -> Identifier { reject }
    "using"            -> Identifier { reject }
    "virtual"          -> Identifier { reject }
    "void"             -> Identifier { reject }
    "volatile"         -> Identifier { reject }
    "wchar_t"          -> Identifier { reject }
    "while"            -> Identifier { reject }

    %% 2.11 [lex.key]
    "and"    -> Identifier { reject }
    "and_eq" -> Identifier { reject }
    "bitand" -> Identifier { reject }
    "bitor"  -> Identifier { reject }
    "compl"  -> Identifier { reject }
    "not"    -> Identifier { reject }
    "not_eq" -> Identifier { reject }
    "or"     -> Identifier { reject }
    "or_eq"  -> Identifier { reject }
    "xor"    -> Identifier { reject }
    "xor_eq" -> Identifier { reject }

  %% "intmain" is an identifier, not a keyword followed by an identifier
  lexical restrictions
    "asm"		-/- [a-zA-Z0-9\_]
    "auto"		-/- [a-zA-Z0-9\_]
    "bool"		-/- [a-zA-Z0-9\_]
    "break"		-/- [a-zA-Z0-9\_]
    "case"		-/- [a-zA-Z0-9\_]
    "catch"		-/- [a-zA-Z0-9\_]
    "char"		-/- [a-zA-Z0-9\_]
    "class"		-/- [a-zA-Z0-9\_]
    "const"		-/- [a-zA-Z0-9\_]
    "const_cast"	-/- [a-zA-Z0-9\_]
    "continue"		-/- [a-zA-Z0-9\_]
    "default"		-/- [a-zA-Z0-9\_]
    "delete"		-/- [a-zA-Z0-9\_]
    "do"		-/- [a-zA-Z0-9\_]
    "double"		-/- [a-zA-Z0-9\_]
    "dynamic_cast"	-/- [a-zA-Z0-9\_]
    "else"		-/- [a-zA-Z0-9\_]
    "enum"		-/- [a-zA-Z0-9\_]
    "explicit"		-/- [a-zA-Z0-9\_]
    "export"		-/- [a-zA-Z0-9\_]
    "extern"		-/- [a-zA-Z0-9\_]
    "false"		-/- [a-zA-Z0-9\_]
    "float"		-/- [a-zA-Z0-9\_]
    "for"		-/- [a-zA-Z0-9\_]
    "friend"		-/- [a-zA-Z0-9\_]
    "goto"		-/- [a-zA-Z0-9\_]
    "if"		-/- [a-zA-Z0-9\_]
    "inline"		-/- [a-zA-Z0-9\_]
    "int"		-/- [a-zA-Z0-9\_]
    "long"		-/- [a-zA-Z0-9\_]
    "mutable"		-/- [a-zA-Z0-9\_]
    "namespace"		-/- [a-zA-Z0-9\_]
    "new"		-/- [a-zA-Z0-9\_]
    "operator"		-/- [a-zA-Z0-9\_]
    "private"		-/- [a-zA-Z0-9\_]
    "protected"		-/- [a-zA-Z0-9\_]
    "public"		-/- [a-zA-Z0-9\_]
    "register"		-/- [a-zA-Z0-9\_]
    "reinterpret_cast"	-/- [a-zA-Z0-9\_]
    "return"		-/- [a-zA-Z0-9\_]
    "short"		-/- [a-zA-Z0-9\_]
    "signed"		-/- [a-zA-Z0-9\_]
    "sizeof"		-/- [a-zA-Z0-9\_]
    "static"		-/- [a-zA-Z0-9\_]
    "static_cast"	-/- [a-zA-Z0-9\_]
    "struct"		-/- [a-zA-Z0-9\_]
    "switch"		-/- [a-zA-Z0-9\_]
    "template"		-/- [a-zA-Z0-9\_]
    "this"		-/- [a-zA-Z0-9\_]
    "throw"		-/- [a-zA-Z0-9\_]
    "true"		-/- [a-zA-Z0-9\_]
    "try"		-/- [a-zA-Z0-9\_]
    "typedef"		-/- [a-zA-Z0-9\_]
    "typeid"		-/- [a-zA-Z0-9\_]
    "typename"		-/- [a-zA-Z0-9\_]
    "union"		-/- [a-zA-Z0-9\_]
    "unsigned"		-/- [a-zA-Z0-9\_]
    "using"		-/- [a-zA-Z0-9\_]
    "virtual"		-/- [a-zA-Z0-9\_]
    "void"		-/- [a-zA-Z0-9\_]
    "volatile"		-/- [a-zA-Z0-9\_]
    "wchar_t"		-/- [a-zA-Z0-9\_]
    "while"		-/- [a-zA-Z0-9\_]
    "and"		-/- [a-zA-Z0-9\_]
    "and_eq"		-/- [a-zA-Z0-9\_]
    "bitand"		-/- [a-zA-Z0-9\_]
    "bitor"		-/- [a-zA-Z0-9\_]
    "compl"		-/- [a-zA-Z0-9\_]
    "not"		-/- [a-zA-Z0-9\_]
    "not_eq"		-/- [a-zA-Z0-9\_]
    "or"		-/- [a-zA-Z0-9\_]
    "or_eq"		-/- [a-zA-Z0-9\_]
    "xor"		-/- [a-zA-Z0-9\_]
    "xor_eq"		-/- [a-zA-Z0-9\_]
module AccessSpecifiers

exports

  sorts
    AccessSpecifier

  context-free syntax

    %% 10 [class.derived]
    "private"   -> AccessSpecifier
    "protected" -> AccessSpecifier
    "public"    -> AccessSpecifier

module StorageClassSpecifiers

imports

exports

  sorts
    StorageClassSpecifier

  context-free syntax

    %% 7.1.1 [dcl.stc]
    "auto"     -> StorageClassSpecifier
    "register" -> StorageClassSpecifier
    "static"   -> StorageClassSpecifier
    "extern"   -> StorageClassSpecifier
    "mutable"  -> StorageClassSpecifier

module UnaryExpressions

imports

  CastExpressions
  DeleteExpressions
  NewExpressions
  PostfixExpressions

exports

  sorts
    UnaryOperator

exports

  sorts
    UnaryExpression

  context-free syntax

    %% 5.3 [expr.unary]
    PostfixExpression            -> UnaryExpression
    "++" CastExpression          -> UnaryExpression
    "--" CastExpression          -> UnaryExpression
    UnaryOperator CastExpression -> UnaryExpression
    "sizeof" UnaryExpression     -> UnaryExpression
    "sizeof" "(" TypeId ")"      -> UnaryExpression
    NewExpression                -> UnaryExpression
    DeleteExpression             -> UnaryExpression

    %% 5.3 [expr.unary]
    "*" -> UnaryOperator	{cons("Indirection")}
    "&" -> UnaryOperator	{cons("Address")}
    "+" -> UnaryOperator	{cons("Pos")}
    "-" -> UnaryOperator	{cons("Neg")}
    "!" -> UnaryOperator	{cons("LogicalNot")}
    "not" -> UnaryOperator      {cons("LogicalNot")}
    "~" -> UnaryOperator	{cons("BinaryNot")}
    "compl" -> UnaryOperator    {cons("BinaryNot")}
module JumpStatements

imports

  Expressions
  Identifiers

exports

  sorts
    JumpStatement

  context-free syntax

    %% 6.6 [stmt.jump]
    "break" ";"              -> JumpStatement

    "continue" ";"           -> JumpStatement

    "return" exp:Expression? ";" -> JumpStatement

    "goto" id:Identifier ";"    -> JumpStatement

module Statements

imports

  CompoundStatements
  DeclarationStatements
  ExpressionStatements
  IterationStatements
  JumpStatements
  LabeledStatements
  SelectionStatements
  TryBlocks

exports

  sorts
    Statement

  context-free syntax

    %% 6 [stmt.stmt]
    LabeledStatement     -> Statement
    ExpressionStatement  -> Statement
    CompoundStatement    -> Statement
    SelectionStatement   -> Statement
    IterationStatement   -> Statement
    JumpStatement        -> Statement
    DeclarationStatement -> Statement
    TryBlock             -> Statement

module TypeSpecifiers

imports

  ClassSpecifiers
  CvQualifiers
  ElaboratedTypeSpecifiers
  EnumSpecifiers
  SimpleTypeSpecifiers

exports

  sorts
    TypeSpecifier

  context-free syntax

    %% 7.1.5 [dcl.type]
    SimpleTypeSpecifier     -> TypeSpecifier

    ClassSpecifier          -> TypeSpecifier

    EnumSpecifier           -> TypeSpecifier

    ElaboratedTypeSpecifier -> TypeSpecifier

    CvQualifier             -> TypeSpecifier


module Layout

exports

   sorts
    ASTERISK

exports

  lexical syntax

    [\*] -> ASTERISK

    [\ \t\n]                    -> LAYOUT
    "//" ~[\n]* [\n]            -> LAYOUT
    "/*" (~[\*]|ASTERISK)* "*/" -> LAYOUT

  lexical restrictions

    ASTERISK -/- [\/]

  context-free restrictions

    LAYOUT? -/- [\ \t\n] | [\/].[\/] | [\/].[\/\*].~[\<]
module ExpressionStatements

imports

  Expressions

exports

  sorts
     ExpressionStatement

  context-free syntax

    %% 6.2 [stmt.expr]
    expr:Expression? ";" -> ExpressionStatement

module AsmDefinitions

imports

  StringLiterals

exports

  sorts
    AsmDefinition

  context-free syntax

    %% 7.4 [dcl.asm]
    "asm" "(" StringLiteral ")" ";" -> AsmDefinition

module BooleanLiterals

imports

  Characters

exports

  sorts
    BOOLEAN-LITERAL

exports

  sorts
    BooleanLiteral

  lexical syntax

    %% 2.13.5 [lex.bool]
    "true"  -> BOOLEAN-LITERAL
    "false" -> BOOLEAN-LITERAL

  context-free syntax

    BOOLEAN-LITERAL -> BooleanLiteral

module LabeledStatements

imports

  Identifiers
  Statements
  ConstantExpressions

exports

  sorts
    LabeledStatement

  context-free syntax

    %% 6.1 [stmt.label]
    Identifier ":" Statement                -> LabeledStatement
    "case" ConstantExpression ":" Statement -> LabeledStatement
    "default" ":" Statement                 -> LabeledStatement

module UsingDeclarations

imports

  IdExpressions

exports

  sorts
    UsingDeclaration

  context-free syntax

    %% 7.3.3 [namespace.udecl]
    "using" tn:"typename"? Root NestedNameSpecifier UnqualifiedId ";"
                                                       -> UsingDeclaration

    "using" "::" UnqualifiedId ";"                     -> UsingDeclaration


module PrimaryExpressions

imports

  Expressions
  IdExpressions
  Literals

exports

  sorts
    PrimaryExpression

  context-free syntax

    %% 5.1 [expr.prim]
    Literal            -> PrimaryExpression
    "this"             -> PrimaryExpression {cons("this")}
    "(" Expression ")" -> PrimaryExpression

    IdExpression       -> PrimaryExpression

module ShiftExpressions

imports

  AdditiveExpressions

exports

  sorts
    ShiftExpression

  context-free syntax

   %% 5.8 [expr.shift]
   AdditiveExpression                      -> ShiftExpression
   ShiftExpression "<<" AdditiveExpression -> ShiftExpression

   ShiftExpression ">>" AdditiveExpression -> ShiftExpression

module Expressions

imports

  AssignmentExpressions

exports

  sorts
     Expression

  context-free syntax

    %% 5.18 [expr.comma]
    list:{ AssignmentExpression "," }+ -> Expression

module Declarations

imports

  AsmDefinitions
  InitDeclarators
  ExplicitInstantiations
  ExplicitSpecializations
  FunctionDefinitions
  LinkageSpecifications
  NamespaceAliases
  Namespaces
  Specifiers
  TemplateDeclarations
  UsingDeclarations
  UsingDirectives

exports

  sorts

exports

  sorts
    Declaration
    DeclarationSeq
    BlockDeclaration
    SimpleDeclaration


  context-free syntax

    %% 7 [dcl.dcl]
    seq:Declaration+ -> DeclarationSeq

    %% 7 [dcl.dcl]
    BlockDeclaration       -> Declaration
    FunctionDefinition     -> Declaration
    TemplateDeclaration    -> Declaration
    ExplicitInstantiation  -> Declaration
    ExplicitSpecialization -> Declaration
    LinkageSpecification   -> Declaration
    NamespaceDefinition    -> Declaration

    %% 7 [dcl.dcl]
    SimpleDeclaration        -> BlockDeclaration
    AsmDefinition            -> BlockDeclaration
    NamespaceAliasDefinition -> BlockDeclaration
    UsingDeclaration         -> BlockDeclaration
    UsingDirective           -> BlockDeclaration

    %% 7 [dcl.dcl]
    ds:DeclSpecifierSeq? idl:InitDeclaratorList? ";" -> SimpleDeclaration

module SimpleTypeSpecifiers

imports

  ClassSpecifiers
  EnumSpecifiers
  IdExpressions
  Identifiers
  TemplateIds

exports

  sorts
    TypeName
    TypedefName
    SimpleTypeSpecifier

  context-free syntax

    %% 7.1.5.2 [dcl.type.simple]
    r:Root nns:NestedNameSpecifier? TypeName         -> SimpleTypeSpecifier

    r:Root NestedNameSpecifier "template" TemplateId -> SimpleTypeSpecifier

    "char"                                        -> SimpleTypeSpecifier

    "wchar_t"                                     -> SimpleTypeSpecifier

    "bool"                                        -> SimpleTypeSpecifier

    "short"                                       -> SimpleTypeSpecifier

    "int"                                         -> SimpleTypeSpecifier

    "long"                                        -> SimpleTypeSpecifier

    "signed"                                      -> SimpleTypeSpecifier

    "unsigned"                                    -> SimpleTypeSpecifier

    "float"                                       -> SimpleTypeSpecifier

    "double"                                      -> SimpleTypeSpecifier

    "void"                                        -> SimpleTypeSpecifier


    %% 7.1.5.2 [dcl.type.simple]
    ClassName   -> TypeName

    EnumName    -> TypeName

    TypedefName -> TypeName


    %% A.1 [gram.key]
    Identifier -> TypedefName

module FunctionDefinitions

imports

   CompoundStatements
   CtorInitializers
   Declarators
   Specifiers
   TryBlocks

exports

  sorts
    FunctionDefinition
    FunctionBody

  context-free syntax

    %% 8.4 [dcl.fct.def]
    dss:DeclSpecifierSeq? Declarator ci:CtorInitializer? FunctionBody
                                                       -> FunctionDefinition

    dss:DeclSpecifierSeq? Declarator FunctionTryBlock
                                                       -> FunctionDefinition

    "buggy" -> FunctionDefinition {avoid}

    %% 8.4 [dcl.fct.def]
    CompoundStatement -> FunctionBody

module Literals

imports

  BooleanLiterals
  CharacterLiterals
  FloatingLiterals
  IntegerLiterals
  Layout
  StringLiterals

exports

  sorts
    Literal

  context-free syntax

    %% 2.13 [lex.literal]
    IntegerLiteral   -> Literal
    CharacterLiteral -> Literal
    FloatingLiteral  -> Literal
    StringLiteral    -> Literal
    BooleanLiteral   -> Literal

module ExplicitSpecializations

imports

  Declarations

exports

  sorts
    ExplicitSpecialization

  context-free syntax

    %% 14.7.3 [temp.expl.spec]
    "template" "<" ">" Declaration -> ExplicitSpecialization

module IdExpressions

imports

  ClassSpecifiers
  ConversionFunctionIds
  Identifiers
  Keywords
  Namespaces
  OperatorFunctionIds
  TemplateIds

exports

  sorts
    ClassOrNamespaceName
    IdExpression
    QualifiedId
    NestedNameSpecifier
    UnqualifiedId
    Root

  context-free syntax

    %% 5.1 [expr.prim]
    UnqualifiedId -> IdExpression

    QualifiedId   -> IdExpression

    %% 5.1 [expr.prim]
    Identifier           -> UnqualifiedId

    OperatorFunctionId   -> UnqualifiedId

    ConversionFunctionId -> UnqualifiedId

    "~" ClassName        -> UnqualifiedId

    TemplateId           -> UnqualifiedId

    %% 5.1 [expr.prim]
    r:Root NestedNameSpecifier template:"template"? UnqualifiedId
                                                             -> QualifiedId

    "::" -> Root

         -> Root

    "::" Identifier                                          -> QualifiedId
    "::" OperatorFunctionId                                  -> QualifiedId
    "::" TemplateId                                          -> QualifiedId

    %% 5.1 [expr.prim]
    ClassOrNamespaceName "::" nns:NestedNameSpecifier? -> NestedNameSpecifier
    ClassOrNamespaceName "::" "template" NestedNameSpecifier
                                                       -> NestedNameSpecifier

    %% 5.1 [expr.prim]
    ClassName     -> ClassOrNamespaceName
    NamespaceName -> ClassOrNamespaceName

module Characters

imports

  Layout

exports

  sorts
    DIGIT
    NON-DIGIT
    NONZERO-DIGIT
    SOURCE-CHARACTER
    S-SOURCE-CHARACTER
    C-SOURCE-CHARACTER
    OCTAL-DIGIT
    LOW-OCTAL-DIGIT
    HIGH-OCTAL-DIGIT
    HEXADECIMAL-DIGIT

  lexical syntax

    %% 2.2 [lex.charset]
    [a-zA-Z0-9\_\{\}\[\]\#\(\)\<\>\%\:\;\.\?\*\+\-\/\^\&\|\~\!\=\,\"\'\ \n\t\\]
                                                        -> SOURCE-CHARACTER
    [a-zA-Z0-9\_\{\}\[\]\#\(\)\<\>\%\:\;\.\?\*\+\-\/\^\&\|\~\!\=\,\'\ \t]
                                                        -> S-SOURCE-CHARACTER
    [a-zA-Z0-9\_\{\}\[\]\#\(\)\<\>\%\:\;\.\?\*\+\-\/\^\&\|\~\!\=\,\"\ \t]
                                                        -> C-SOURCE-CHARACTER

    %% 2.10 [lex.name]
    [0-9] -> DIGIT

    %% 2.10 [lex.name]
    [a-zA-Z\_] -> NON-DIGIT

    %% 2.13.1 [lex.icon]
    [1-9] -> NONZERO-DIGIT

    %% 2.13.1 [lex.icon]
    [0-7]       -> OCTAL-DIGIT
    [0-3]       -> LOW-OCTAL-DIGIT
    [4-7]       -> HIGH-OCTAL-DIGIT
    [0-9a-fA-F] -> HEXADECIMAL-DIGIT

module NamespaceAliases

imports

  IdExpressions
  Identifiers
  Namespaces

exports

  sorts
    QualifiedNamespaceSpecifier

exports

  sorts
    NamespaceAlias
    NamespaceAliasDefinition

  context-free syntax

    %% 7.3.2 [namespace.alias]
    Identifier -> NamespaceAlias

    %% 7.3.2 [namespace.alias]
    "namespace" Identifier "=" QualifiedNamespaceSpecifier ";"
                                                  -> NamespaceAliasDefinition

    %% 7.3.2 [namespace.alias]
    r:Root nns:NestedNameSpecifier? NamespaceName
                                              -> QualifiedNamespaceSpecifier

module TypeIds

imports

  ConstantExpressions
  CvQualifiers
  ExceptionSpecifications
  ParameterDeclarations
  TypeSpecifiers

exports

  sorts
    DirectAbstractDeclarator

exports

  sorts
    AbstractDeclarator
    TypeSpecifierSeq
    TypeId

  context-free syntax

    %% 8.1 [dcl.name]
    TypeSpecifierSeq ad:AbstractDeclarator? -> TypeId

    %% 8.1 [dcl.name]
    ts:TypeSpecifier+ -> TypeSpecifierSeq

    l:TypeSpecifier+ r:TypeSpecifier+ -> TypeSpecifier+
        {left}

    %%FIXME
    TypeSpecifier+ TypeSpecifier* -> TypeSpecifier+
      {avoid}
    TypeSpecifier* TypeSpecifier+ -> TypeSpecifier+
      {avoid}

    TypeSpecifier -> TypeSpecifier+

    %% 8.1 [dcl.name]
    PtrOperator ad:AbstractDeclarator? -> AbstractDeclarator

    ad:AbstractDeclarator -> AbstractDeclarator?

                          -> AbstractDeclarator?

    DirectAbstractDeclarator        -> AbstractDeclarator


    DirectAbstractDeclarator -> DirectAbstractDeclarator?
                             -> DirectAbstractDeclarator?

    %% 8.1 [dcl.name]
    dad:DirectAbstractDeclarator? "(" ParameterDeclarationClause ")"
    cqs:CvQualifierSeq? es:ExceptionSpecification? -> DirectAbstractDeclarator

    ExceptionSpecification -> ExceptionSpecification?
                           -> ExceptionSpecification?

    dad:DirectAbstractDeclarator? "[" ce:ConstantExpression? "]"
                                                   -> DirectAbstractDeclarator

    "(" AbstractDeclarator ")"                     -> DirectAbstractDeclarator

  lexical restrictions
    "+" -/- [\+]
    "-" -/- [\-]
module ExceptionSpecifications

imports

  TypeIds

exports

  sorts
    TypeIdList

exports

  sorts
    ExceptionSpecification

  context-free syntax

    %% 15.4 [except.spec]
    "throw" "(" til:TypeIdList? ")" -> ExceptionSpecification

    TypeIdList -> TypeIdList?
               -> TypeIdList?

    %% 15.4 [except.spec]
    list:{ TypeId "," }+            -> TypeIdList

    l:{TypeId ","}+ "," r:{TypeId ","}+ -> {TypeId ","}+
        {left}

    TypeId -> {TypeId ","}+

    %%FIXME
    {TypeId ","}+ "," {TypeId ","}* -> {TypeId ","}+
      {avoid}
    {TypeId ","}* "," {TypeId ","}+ -> {TypeId ","}+
      {avoid}
module BaseSpecifiers

imports

  AccessSpecifiers
  ClassSpecifiers
  IdExpressions

exports

  sorts
    BaseSpecifierList
    BaseSpecifier

exports

  sorts
    BaseClause

  context-free syntax

    BaseClause -> BaseClause?

    %% 10 [class.derived]
    ":" BaseSpecifierList -> BaseClause

    %% 10 [class.derived]
    list:{ BaseSpecifier "," }+ -> BaseSpecifierList
    %% 10 [class.derived]
    r:Root nns:NestedNameSpecifier? ClassName
                                                       -> BaseSpecifier

    "virtual" as:AccessSpecifier? r:Root nns:NestedNameSpecifier? ClassName
                                                       -> BaseSpecifier

    AccessSpecifier virt:"virtual"? r:Root nns:NestedNameSpecifier?
    ClassName                                          -> BaseSpecifier

module AndExpressions

imports

  EqualityExpressions

exports

  sorts
    AndExpression

  context-free syntax

    %% 5.11 [expr.bit.and]
    EqualityExpression                   -> AndExpression
    AndExpression "&" EqualityExpression -> AndExpression
    AndExpression "bitand" EqualityExpression -> AndExpression

  context-free restrictions
    "&" -/- [\&]
module ExplicitInstantiations

imports

  Declarations

exports

  sorts
    ExplicitInstantiation

  context-free syntax

    %% 14.7.2 [temp.explicit]
    "template" Declaration -> ExplicitInstantiation

module ConditionalExpressions

imports

  AssignmentExpressions
  Expressions
  LogicalOrExpressions

exports

  sorts
    ConditionalExpression

  context-free syntax

    %% 5.16 [expr.cond]
    LogicalOrExpression
                                                     -> ConditionalExpression
    LogicalOrExpression "?" Expression ":" AssignmentExpression
                                                     -> ConditionalExpression

module MultiplicativeExpressions

imports

  PmExpressions

exports

  sorts
    MultiplicativeExpression

  context-free syntax

    %% 5.6 [expr.mul]
    PmExpression                              -> MultiplicativeExpression
    MultiplicativeExpression "*" PmExpression -> MultiplicativeExpression

    MultiplicativeExpression "/" PmExpression -> MultiplicativeExpression
    MultiplicativeExpression "%" PmExpression -> MultiplicativeExpression

module FloatingLiterals

imports

  Characters

exports

  sorts
     FLOATING-LITERAL
     FRACTIONAL-CONSTANT
     EXPONENT-PART
     SIGN
     FLOATING-SUFFIX

exports

  sorts
     FloatingLiteral

  lexical syntax

    %% 2.13.3 [lex.fcon]
    FRACTIONAL-CONSTANT EXPONENT-PART? FLOATING-SUFFIX? -> FLOATING-LITERAL
    DIGIT+ EXPONENT-PART FLOATING-SUFFIX?               -> FLOATING-LITERAL

    %% 2.13.3 [lex.fcon]
    DIGIT* "." DIGIT+ -> FRACTIONAL-CONSTANT
    DIGIT+ "."        -> FRACTIONAL-CONSTANT

    %% 2.13.3 [lex.fcon]
    [eE] SIGN? DIGIT+ -> EXPONENT-PART

    %% 2.13.3 [lex.fcon]
    [\+\-] -> SIGN

    %% 2.13.3 [lex.fcon]
    [flFL] -> FLOATING-SUFFIX

  context-free syntax

    FLOATING-LITERAL -> FloatingLiteral

module TranslationUnits

imports

  Declarations

exports

  sorts

    TranslationUnit

  context-free syntax

    %% A.3 [gram.basic]
    ds:DeclarationSeq? -> TranslationUnit

module LogicalAndExpressions

imports

  InclusiveOrExpressions

exports

  sorts
    LogicalAndExpression

  context-free syntax

    %% 5.14 [expr.log.and]
    InclusiveOrExpression                            -> LogicalAndExpression
    LogicalAndExpression "&&" InclusiveOrExpression  -> LogicalAndExpression

    LogicalAndExpression "and" InclusiveOrExpression -> LogicalAndExpression

module ParameterDeclarations

imports

  AssignmentExpressions
  Declarators
  Specifiers
  TypeIds

exports

  sorts
    ParameterDeclarationList

exports

  sorts
    ParameterDeclaration
    ParameterDeclarationClause

  context-free syntax

    %% 8.3.5 [dcl.fct]
    pdl:ParameterDeclarationList? etc:"..."?   -> ParameterDeclarationClause

    ParameterDeclarationList -> ParameterDeclarationList?

                             -> ParameterDeclarationList?

    ParameterDeclarationList "," "..."         -> ParameterDeclarationClause

    %% 8.3.5 [dcl.fct]
    list:{ ParameterDeclaration "," }+  -> ParameterDeclarationList

    l:{ParameterDeclaration ","}+ "," r:{ParameterDeclaration ","}+
      -> {ParameterDeclaration ","}+

    ParameterDeclaration -> {ParameterDeclaration ","}+

    %%FIXME
    {ParameterDeclaration ","}+ "," {ParameterDeclaration ","}*
      -> {ParameterDeclaration ","}+
      {avoid}
    {ParameterDeclaration ","}* "," {ParameterDeclaration ","}+
      -> {ParameterDeclaration ","}+
      {avoid}

    %% 8.3.5 [dcl.fct]
    DeclSpecifierSeq Declarator                      -> ParameterDeclaration

    DeclSpecifierSeq Declarator "=" AssignmentExpression
                                                     -> ParameterDeclaration

    DeclSpecifierSeq ad:AbstractDeclarator?          -> ParameterDeclaration


    DeclSpecifierSeq ad:AbstractDeclarator? "=" AssignmentExpression
                                                     -> ParameterDeclaration


module CharacterLiterals

imports

  Characters
  EscapeSequences

exports

  sorts
    CHARACTER-LITERAL
    C-CHAR-SEQUENCE
    C-CHAR

exports

  sorts
    CharacterLiteral

  lexical syntax

    %% 2.13.2 [lex.ccon]
    "'" C-CHAR-SEQUENCE "'"  -> CHARACTER-LITERAL
    "L'" C-CHAR-SEQUENCE "'" -> CHARACTER-LITERAL

    %% 2.13.2 [lex.ccon]
    C-CHAR+ -> C-CHAR-SEQUENCE

    %% 2.13.2 [lex.ccon]
    C-SOURCE-CHARACTER       -> C-CHAR
    ESCAPE-SEQUENCE          -> C-CHAR
    UNIVERSAL-CHARACTER-NAME -> C-CHAR

  context-free syntax

    CHARACTER-LITERAL -> CharacterLiteral

module PostfixExpressions

imports

  AssignmentExpressions
  Expressions
  IdExpressions
  PrimaryExpressions
  TemplateIds

exports

  sorts
    PseudoDestructorName

exports

  sorts
    ExpressionList
    PostfixExpression

  context-free syntax

    %% 5.2 [expr.post]
    PrimaryExpression                                                                   -> PostfixExpression

    PostfixExpression "[" Expression "]"                 -> PostfixExpression

    PostfixExpression "(" el:ExpressionList? ")"         -> PostfixExpression

    SimpleTypeSpecifier "(" el:ExpressionList? ")"       -> PostfixExpression

    "typename" root:"::"? NestedNameSpecifier Identifier
    "(" el:ExpressionList? ")"                           -> PostfixExpression

    "typename" root:"::"? NestedNameSpecifier template:"template"?
    TemplateId "(" el:ExpressionList? ")"                -> PostfixExpression

    PostfixExpression "." template:"template"? IdExpression
                                                         -> PostfixExpression

    PostfixExpression "->" template:"template"? IdExpression
                                                         -> PostfixExpression

    PostfixExpression "." PseudoDestructorName           -> PostfixExpression

    PostfixExpression "->" PseudoDestructorName          -> PostfixExpression

    PostfixExpression "++"                               -> PostfixExpression

    PostfixExpression "--"                               -> PostfixExpression

    "dynamic_cast" "<" TypeId ">" "(" Expression ")"     -> PostfixExpression

    "static_cast" "<" TypeId ">" "(" Expression ")"      -> PostfixExpression

    "reinterpret_cast" "<" TypeId ">" "(" Expression ")" -> PostfixExpression

    "const_cast" "<" TypeId ">" "(" Expression ")"       -> PostfixExpression

    "typeid" "(" Expression ")"                          -> PostfixExpression

    "typeid" "(" TypeId ")"                              -> PostfixExpression

    %% 5.2 [expr.post]
    list:{ AssignmentExpression "," }+ -> ExpressionList

    %% 5.2 [expr.post]
    root:"::"? nns:NestedNameSpecifier? TypeName "::" "~" TypeName
                                                        -> PseudoDestructorName

    root:"::"? NestedNameSpecifier "template" TemplateId "::" "~" TypeName
                                                        -> PseudoDestructorName

    root:"::"? nns:NestedNameSpecifier? "~" TypeName    -> PseudoDestructorName

module TryBlocks

imports

  CompoundStatements
  CtorInitializers
  Declarators
  FunctionDefinitions
  TypeIds

exports

  sorts
    HandlerSeq
    Handler
    ExceptionDeclaration

exports

  sorts
    TryBlock
    FunctionTryBlock

  context-free syntax

    %% 15 [except]
    "try" CompoundStatement HandlerSeq -> TryBlock

    %% 15 [except]
    "try" ci:CtorInitializer? FunctionBody HandlerSeq -> FunctionTryBlock

    %% 15 [except]
    Handler+ -> HandlerSeq

    %% 15 [except]
    "catch" "(" ExceptionDeclaration ")" CompoundStatement -> Handler

    %% 15 [except]
    TypeSpecifierSeq Declarator         -> ExceptionDeclaration
    TypeSpecifierSeq AbstractDeclarator -> ExceptionDeclaration
    TypeSpecifierSeq                    -> ExceptionDeclaration
    "..."                               -> ExceptionDeclaration

module AdditiveExpressions

imports

  MultiplicativeExpressions

exports

  sorts
    AdditiveExpression

  context-free syntax

    %% 5.7 [expr.add]
    MultiplicativeExpression                        -> AdditiveExpression
    AdditiveExpression "+" MultiplicativeExpression -> AdditiveExpression
    AdditiveExpression "-" MultiplicativeExpression -> AdditiveExpression

module ClassSpecifiers

imports

  BaseSpecifiers
  IdExpressions
  Identifiers
  MemberSpecifications
  TemplateIds

exports

  sorts
    ClassSpecifier
    ClassHead
    ClassName
    ClassKey

  context-free syntax

    %% 9 [class]
    Identifier -> ClassName

    TemplateId -> ClassName

    %% 9 [class]
    ClassHead "{" ms:MemberSpecification? "}" -> ClassSpecifier

    %% 9 [class]
    ClassKey i:Identifier? bc:BaseClause?                     -> ClassHead

    ClassKey NestedNameSpecifier Identifier bc:BaseClause?     -> ClassHead
    ClassKey ns:NestedNameSpecifier? TemplateId bc:BaseClause? -> ClassHead

    %% 9 [class]
    "class"  -> ClassKey

    "struct" -> ClassKey

    "union"  -> ClassKey

module CvQualifiers

exports

  sorts
    CvQualifier
    CvQualifierSeq

  context-free syntax

    %% 7.1.5.1 [dcl.type.cv]
    "const"    -> CvQualifier {cons("const")}
    "volatile" -> CvQualifier {cons("volatile")}

    %% 8 [dcl.decl]
    cqs:CvQualifier+ -> CvQualifierSeq

   %%FIXME
 CvQualifier+ CvQualifier* -> CvQualifier+
      {avoid}
 CvQualifier* CvQualifier+ -> CvQualifier+
      {avoid}

    l:CvQualifier+ r:CvQualifier+ -> CvQualifier+
      {left}

    CvQualifier -> CvQualifier+

module ConversionFunctionIds

imports

  Declarators

exports

  sorts
     ConversionTypeId
     ConversionDeclarator

exports

  sorts
     ConversionFunctionId

  context-free syntax

    %% A.10 [gram.special]
    "operator" ConversionTypeId -> ConversionFunctionId

    %% A.10 [gram.special]
    TypeSpecifierSeq cd:ConversionDeclarator? -> ConversionTypeId

    %% A.10 [gram.special]
    PtrOperator cd:ConversionDeclarator? -> ConversionDeclarator

    ConversionDeclarator                 -> ConversionDeclarator?

                                         -> ConversionDeclarator?

module Identifiers

imports

  Layout
  Characters

exports

  sorts
    ID

exports

  sorts
    Identifier

  lexical syntax

    %% 2.10 [lex.name]
    NON-DIGIT(NON-DIGIT|DIGIT)* -> ID

  lexical restrictions
    ID -/- [a-zA-Z0-9\_]

  context-free syntax

    %% 2.10 [lex.name]
    ID -> Identifier


    Identifier -> Identifier?

               -> Identifier?

module RelationalExpressions

imports

  ShiftExpressions

exports

  sorts
    RelationalExpression

  context-free syntax

    %% 5.9 [expr.rel]
    ShiftExpression                           -> RelationalExpression
    RelationalExpression "<" ShiftExpression  -> RelationalExpression

    RelationalExpression ">" ShiftExpression  -> RelationalExpression

    RelationalExpression "<=" ShiftExpression -> RelationalExpression

    RelationalExpression ">=" ShiftExpression -> RelationalExpression

  lexical restrictions

    "<" -/- [\<]
    ">" -/- [\>]
